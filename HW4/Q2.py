from fractions import gcd

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

c = 49346329369462854363271782448315211099681514434640599974621854671392427139371635210345363031473153599464348320842322740635553960642953510895196069229258786536891749021841437200659026184844350444165516427177404248892439049448334399411189045056185102422704738091759473313311163625490140702356058569205275317138
p = 5101992342203516357697535790036406465112696833686666892830644684923604789578858837330734668955362945351024616140475938505160037019389600812468312274731287
q = 10467785804023663154081159890916670751197684284050596453663074112949922468570225369830419350044296830552368635876390157350061674041677409479215017880761471
e1 = 65537
e2 = 65539
n = p * q
w = (p - 1) * (q - 1)
e3 = (e1 * e2) % w
d3 = modinv(e3, w)

d2 = modinv(e2, w)
d1 = modinv(e1, w)

c1 = pow(c, d2, n)
m1 = pow(c1, d1, n)
print "m:", m1      # Double Modular Exponentiation

m2 = pow(c, d3, n)
print "m:", m2      # Single Modular Exponentiation

print "d3:", d3
print "e3:", e3
